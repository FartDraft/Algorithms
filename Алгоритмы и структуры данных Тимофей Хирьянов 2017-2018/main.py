from math import sqrt


def sieve(n: int) -> list:
    """Обычное решето Эратосфена. Алгоритм проверки чисел на простоту до заданного 
        натурального числа (включительно) путём постепенного отсеивания составных чисел.

    Args:
        n (int):  натуральное число, включительно до которого будут проверены на простоту.

    Returns:
        list: массив bool значений. 
            Каждый индекс соответствует числу. True - если число простое, иначе - False.
    """
    assert n > 2, "n меньше чем 2"
    ret = [False, False] + [True] * (n - 1)
    for k in range(2, int(sqrt(n)) + 1):
        if ret[k]:
            for i in range(k * k, n + 1, k):
                ret[i] = False
    return ret


def insertion_sort(arr: list) -> list:
    """Сортировка массива по возрастанию методом вставок. O(N**2).
    Идея:
        В начале каждой итерации цикла for есть отсортированный подмассив из элементов arr[:top], но в отсортированном порядке.

    Args:
        arr (list): исходный массив.

    Returns:
        list: отсортированный по возрастанию массив из элементов массива arr.
    """
    for top in range(1, len(arr)):
        k = top
        # and - ленивое(не будет вычислять 2 выражение, если первое ложно).
        while k > 0 and arr[k - 1] > arr[k]:
            arr[k], arr[k - 1] = arr[k - 1], arr[k]
            k -= 1


def selection_sort(arr: list) -> list:
    """Сортировка массива по возрастанию методом выбора. O(N**2).
    Идея:
        В каждой итерации цикла for ищет минимальный элемент из подмассива arr[pos:] и меняет его местами с arr[pos].

    Args:
        arr (list): исходный массив.

    Returns:
        list: отсортированный по возрастанию массив из элементов массива arr.
    """
    n = len(arr)
    for pos in range(n - 1):
        # Находим индекс минимального элемента массива arr.
        k = min(range(pos, n), key=arr.__getitem__)
        arr[pos], arr[k] = arr[k], arr[pos]
    

def bubble_sort(arr: list) -> list:
    """Сортировка массива по возрастанию методом пузырька. O(N**2).
    Идея:
        В конце каждой итерации цикла (1) максимум из подмассива arr[:i + 1] стоит в arr[i].
        Цикл (2) обходит массив arr[:i], попутно меняя местами неотсортированные соседние элементы.
        Если к концу очередной итерации цикла (2) никаких обменов не произошло, то массив уже отсортирован.
    Args:
        arr (list): исходный массив.

    Returns:
        list: отсортированный по возрастанию массив из элементов массива arr.
    """
    for border in range(len(arr) - 1, 0, -1):  #(1).
        no_swap = True
        for j in range(border):  #(2).
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                no_swap = False
        if no_swap:
            break


def gcd(a: int, b: int) -> int:
    """Алгоритм нахождения наибольшего общего делителя чисел a и b.

    Args:
        a (int): Первое число.
        b (int): Второе число.

    Returns:
        int: НОД чисел a и b.
    """
    return a if b == 0 else gcd(b, a % b)


def fast_pow(a: float, n: int) -> int:
    """Алгоритм быстрого возведения числа a в степень n.

    Args:
        a (float): число.
        n (int): степень.

    Returns:
        int: результат.
    """
    if n == 0:
        return 1
    elif n % 2:
        return fast_pow(a, n - 1) * a
    else:
        return fast_pow(a * a, n // 2)


def hanoi_towers(n: int, start: int, finish: int) -> None:
    """Алгоритм для решения головоломки "Ханойские башни". Суть головоломки:
    Есть три стержня, пронумерованных числами 1, 2, 3. На стержень start надета пирамидка из n дисков различного диаметра в порядке 
    возрастания диаметра. Диски можно перекладывать с одного стержня на другой по одному, при этом диск нельзя класть на диск меньшего 
    диаметра. Необходимо переложить всю пирамидку со стержня start на стержень finish за минимальное число перекладываний.

    Args:
        n (int): количество дисков.
        start (int): порядковый номер стартового стержня.
        finish (int): порядковый номер конечного стержня.
    """
    if n > 0:
        tmp = 6 - start - finish
        hanoi_towers(n - 1, start, tmp)
        print(f"Перенесите диск {n} со стержня {start} на стержень {finish}.")
        hanoi_towers(n - 1, tmp, finish)
